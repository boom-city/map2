# Monorepo Synchronization Workflow
# Direct translation from .claude/dev-docs/pseudo-code/PSEUDO_WORKFLOW.md
#
# This workflow handles:
# - Upstream sync: monorepo ‚Üí subrepos (triggered by push/PR)
# - Downstream sync: subrepos ‚Üí monorepo (triggered by schedule/manual)
# - Repository bootstrapping, conflict detection, and cleanup
#
# Pseudo-code lines: 1-198

name: "Monorepo Synchronization"

on:
  # Pseudo-code lines: 3-5
  push:
    branches: [main]
  # Pseudo-code lines: 6-7
  pull_request:
    branches: [main]
  # Pseudo-code lines: 8-9
  # schedule:
  #   - cron: "0 * * * *"  # Hourly
  # Pseudo-code line: 10
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  # Job 1: Analysis & Planning (Pseudo-code lines: 54-91)
  analyze_changes:
    name: "Analyze Changes & Generate Execution Plan"
    runs-on: ubuntu-latest
    if: github.event_name == 'push' || github.event_name == 'pull_request'
    outputs:
      execution_plan: ${{ steps.plan.outputs.execution_plan }}
      has_changes: ${{ steps.plan.outputs.has_changes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup GitHub CLI
        run: |
          gh --version
          gh auth status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate execution plan
        id: plan
        run: |
          # Pseudo-code lines: 24-28 - identify_changed_files()
          if [[ "${{ github.event_name }}" == "push" ]]; then
            changed_files=$(gh api /repos/${{ github.repository }}/commits/${{ github.sha }}/files --jq '.[].filename')
          elif [[ "${{ github.event_name }}" == "pull_request" ]]; then
            changed_files=$(gh api /repos/${{ github.repository }}/pulls/${{ github.event.number }}/files --jq '.[].filename')
          fi

          echo "Changed files:"
          echo "$changed_files"

          # Pseudo-code lines: 30-42 - map_files_to_subrepos()
          subrepo_config=$(cat .github/subrepo-config.json)
          execution_matrix="[]"
          has_changes="false"

          # Process each subrepo to determine required actions
          while IFS= read -r subrepo_data; do
            name=$(echo "$subrepo_data" | jq -r '.name')
            prefix=$(echo "$subrepo_data" | jq -r '.prefix')
            remote=$(echo "$subrepo_data" | jq -r '.remote')

            # Check if any changed files affect this subrepo
            affected="false"
            while IFS= read -r file; do
              if [[ "$file" == "$prefix"* ]]; then
                affected="true"
                break
              fi
            done <<< "$changed_files"

            if [[ "$affected" == "true" ]]; then
              has_changes="true"

              # Pseudo-code lines: 67-73 - Determine required action
              action="sync"

              # Pseudo-code lines: 14-18 - check_repository_exists()
              repo_name=$(echo "$remote" | sed 's|https://github.com/||' | sed 's|\.git||')
              if ! gh api "/repos/$repo_name" >/dev/null 2>&1; then
                action="bootstrap"
              else
                # Pseudo-code lines: 20-22 - check_local_git_exists()
                if [[ ! -d "$prefix/.git" ]]; then
                  action="bootstrap"
                else
                  # Pseudo-code lines: 44-50 - check_remote_divergence()
                  remote_head=$(gh api "/repos/$repo_name/commits/main" --jq '.sha' 2>/dev/null || echo "")
                  if [[ -n "$remote_head" ]]; then
                    # Simple divergence check - in production this would be more sophisticated
                    local_head=$(git log --format="%H" -n 1 -- "$prefix" 2>/dev/null || echo "")
                    if [[ "$remote_head" != "$local_head" && -n "$local_head" ]]; then
                      action="report_divergence"
                    fi
                  fi
                fi
              fi

              # Pseudo-code lines: 75-78 - Add to execution matrix
              execution_matrix=$(echo "$execution_matrix" | jq '. + [{
                "name": "'$name'",
                "prefix": "'$prefix'",
                "remote": "'$remote'",
                "repo_name": "'$repo_name'",
                "action": "'$action'"
              }]')
            fi
          done <<< "$(echo "$subrepo_config" | jq -c '.subrepos[]')"

          echo "execution_plan=$execution_matrix" >> $GITHUB_OUTPUT
          echo "has_changes=$has_changes" >> $GITHUB_OUTPUT

          echo "Execution plan:"
          echo "$execution_matrix" | jq '.'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 2: Split & Sync Matrix (Pseudo-code lines: 93-129)
  process_subrepos:
    name: "Process Subrepos"
    runs-on: ubuntu-latest
    needs: [analyze_changes]
    if: needs.analyze_changes.outputs.has_changes == 'true'
    strategy:
      matrix:
        include: ${{ fromJson(needs.analyze_changes.outputs.execution_plan) }}
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup GitHub CLI
        run: |
          gh --version
          gh auth status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Bootstrap subrepo
        if: matrix.action == 'bootstrap'
        run: |
          # Pseudo-code lines: 100-110 - bootstrap_subrepo()
          echo "Bootstrapping subrepo: ${{ matrix.name }}"

          # Create remote repository if it doesn't exist
          if ! gh api "/repos/${{ matrix.repo_name }}" >/dev/null 2>&1; then
            echo "Creating remote repository: ${{ matrix.repo_name }}"
            gh repo create "${{ matrix.repo_name }}" --public --description "Auto-generated from monorepo"
          fi

          # Check if prefix directory exists and has content
          if [[ -d "${{ matrix.prefix }}" ]] && [[ "$(ls -A ${{ matrix.prefix }})" ]]; then
            echo "Performing subtree split and push for: ${{ matrix.prefix }}"

            # Split subtree and push to remote
            split_commit=$(git subtree split --prefix="${{ matrix.prefix }}" --branch="split-${{ matrix.name }}")
            echo "Split commit: $split_commit"

            # Add remote and push
            git remote add "${{ matrix.name }}" "${{ matrix.remote }}" || true
            git push "${{ matrix.name }}" "split-${{ matrix.name }}:main" --force

            # Clean up temporary branch
            git branch -D "split-${{ matrix.name }}" || true
          else
            echo "Warning: Prefix directory ${{ matrix.prefix }} does not exist or is empty"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Sync subrepo
        if: matrix.action == 'sync'
        run: |
          # Pseudo-code lines: 112-119 - sync_subrepo()
          echo "Syncing subrepo: ${{ matrix.name }}"

          # Generate timestamp for unique branch name
          timestamp=$(date +%Y%m%d-%H%M%S)
          temp_branch="sync-${timestamp}"

          # Check if prefix directory exists and has content
          if [[ -d "${{ matrix.prefix }}" ]] && [[ "$(ls -A ${{ matrix.prefix }})" ]]; then
            echo "Performing subtree split for: ${{ matrix.prefix }}"

            # Split subtree
            split_commit=$(git subtree split --prefix="${{ matrix.prefix }}" --branch="$temp_branch")
            echo "Split commit: $split_commit"

            # Add remote and push temporary branch
            git remote add "${{ matrix.name }}" "${{ matrix.remote }}" || true
            git push "${{ matrix.name }}" "$temp_branch" --force

            # Create pull request
            echo "Creating PR for ${{ matrix.repo_name }}"
            gh pr create \
              --repo "${{ matrix.repo_name }}" \
              --base main \
              --head "$temp_branch" \
              --title "Sync from monorepo - $(date '+%Y-%m-%d %H:%M:%S')" \
              --body "Automated sync from monorepo. Changes detected in ${{ matrix.prefix }}" || echo "PR creation failed or already exists"

            # Clean up temporary branch
            git branch -D "$temp_branch" || true
          else
            echo "Warning: Prefix directory ${{ matrix.prefix }} does not exist or is empty"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Report divergence
        if: matrix.action == 'report_divergence'
        run: |
          # Pseudo-code lines: 126-128 - Report divergence
          echo "‚ö†Ô∏è Warning: Divergence detected for ${{ matrix.remote }}"
          echo "Manual review required for: ${{ matrix.name }}"

          # Create an issue for manual review
          gh issue create \
            --title "üîÑ Divergence detected: ${{ matrix.name }}" \
            --body "Divergence detected between monorepo and subrepo **${{ matrix.name }}**.

          **Repository:** ${{ matrix.remote }}
          **Prefix:** ${{ matrix.prefix }}
          **Action required:** Manual review and resolution needed.

          Please review the changes in both repositories and resolve conflicts manually." \
            --label "divergence,manual-review" || echo "Issue already exists or creation failed"
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 3: Cleanup (Pseudo-code lines: 132-156)
  cleanup_monorepo:
    name: "Cleanup Monorepo"
    runs-on: ubuntu-latest
    needs: [process_subrepos]
    if: success() && github.event_name == 'push'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Cleanup synchronized directories
        run: |
          # Pseudo-code lines: 137-149 - cleanup_monorepo()
          echo "Performing cleanup of synchronized directories"

          # Generate timestamp for unique branch name
          timestamp=$(date +%Y%m%d-%H%M%S)
          cleanup_branch="cleanup-${timestamp}"

          # Get successful syncs from previous job (simplified approach)
          # In a real implementation, this would check job outputs
          subrepo_config=$(cat .github/subrepo-config.json)
          has_removals="false"

          # Create cleanup branch
          git checkout -b "$cleanup_branch"

          # Note: Actual cleanup logic would need to be more sophisticated
          # to only remove successfully synchronized directories
          echo "Cleanup branch created: $cleanup_branch"
          echo "Note: Automatic directory removal disabled for safety"
          echo "Manual review recommended for cleanup operations"

          # For safety, we'll create a PR but not automatically remove directories
          if [[ "$has_removals" == "true" ]]; then
            git commit -m "Cleanup: Remove synchronized directories" --allow-empty
            git push origin "$cleanup_branch"

            gh pr create \
              --base main \
              --head "$cleanup_branch" \
              --title "üßπ Cleanup: Remove synchronized directories" \
              --body "Automated cleanup PR for directories that were successfully synchronized to subrepos.

              **‚ö†Ô∏è Review required before merging**

              This PR was automatically generated after successful synchronization." \
              --label "cleanup,automated" || echo "PR creation failed or already exists"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Job 4: Summary (Pseudo-code lines: 158-166)
  post_summary:
    name: "Post Summary"
    runs-on: ubuntu-latest
    needs: [cleanup_monorepo]
    if: always()

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Post workflow summary
        run: |
          # Pseudo-code line: 165 - post_summary_comment()
          echo "## üìä Monorepo Synchronization Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Workflow:** ${{ github.workflow }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "**SHA:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Branch:** ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [[ "${{ needs.analyze_changes.result }}" == "success" ]]; then
            echo "‚úÖ **Analysis:** Completed successfully" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Analysis:** Failed or skipped" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.process_subrepos.result }}" == "success" ]]; then
            echo "‚úÖ **Processing:** Completed successfully" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.process_subrepos.result }}" == "failure" ]]; then
            echo "‚ùå **Processing:** Failed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚è≠Ô∏è **Processing:** Skipped" >> $GITHUB_STEP_SUMMARY
          fi

          if [[ "${{ needs.cleanup_monorepo.result }}" == "success" ]]; then
            echo "‚úÖ **Cleanup:** Completed successfully" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ needs.cleanup_monorepo.result }}" == "failure" ]]; then
            echo "‚ùå **Cleanup:** Failed" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚è≠Ô∏è **Cleanup:** Skipped" >> $GITHUB_STEP_SUMMARY
          fi

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Timestamp:** $(date)" >> $GITHUB_STEP_SUMMARY

  # Job 5: Downstream Sync (Pseudo-code lines: 168-198)
  downstream_sync:
    name: "Downstream Sync"
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup GitHub CLI
        run: |
          gh --version
          gh auth status
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Handle scheduled sync
        run: |
          # Pseudo-code lines: 174-194 - handle_scheduled_sync()
          echo "Starting downstream sync from subrepos to monorepo"

          subrepo_config=$(cat .github/subrepo-config.json)
          changes_detected="false"
          timestamp=$(date +%Y%m%d-%H%M%S)
          sync_branch="downstream-sync-${timestamp}"

          # Create sync branch
          git checkout -b "$sync_branch"

          # Process each subrepo
          while IFS= read -r subrepo_data; do
            name=$(echo "$subrepo_data" | jq -r '.name')
            prefix=$(echo "$subrepo_data" | jq -r '.prefix')
            remote=$(echo "$subrepo_data" | jq -r '.remote')
            repo_name=$(echo "$remote" | sed 's|https://github.com/||' | sed 's|\.git||')

            echo "Processing subrepo: $name"

            # Check if remote repository exists
            if gh api "/repos/$repo_name" >/dev/null 2>&1; then
              # Add remote if not already added
              git remote add "$name" "$remote" 2>/dev/null || true

              # Try to pull changes
              if git subtree pull --prefix="$prefix" "$name" main --squash; then
                echo "‚úÖ Successfully pulled changes for $name"
                changes_detected="true"
              else
                # Pseudo-code lines: 182-185 - Handle merge conflicts
                echo "‚ùå Merge conflict detected in $name"
                git merge --abort 2>/dev/null || true

                # Create issue for manual resolution
                gh issue create \
                  --title "üîÑ Merge conflict in downstream sync: $name" \
                  --body "Merge conflict detected while pulling changes from **$name**.

                **Repository:** $remote
                **Prefix:** $prefix
                **Sync branch:** $sync_branch
                **Action required:** Manual conflict resolution needed.

                Please resolve conflicts manually and complete the sync." \
                  --label "conflict,downstream-sync,manual-review" || echo "Issue creation failed"
              fi
            else
              echo "‚ö†Ô∏è Remote repository $repo_name does not exist, skipping"
            fi
          done <<< "$(echo "$subrepo_config" | jq -c '.subrepos[]')"

          # Pseudo-code lines: 188-193 - Create PR if changes detected
          if [[ "$changes_detected" == "true" ]]; then
            echo "Changes detected, creating PR"

            git add -A
            git commit -m "Downstream sync: Pull changes from subrepos - $(date '+%Y-%m-%d %H:%M:%S')" || echo "No changes to commit"
            git push origin "$sync_branch"

            gh pr create \
              --base main \
              --head "$sync_branch" \
              --title "üîÑ Downstream sync: $(date '+%Y-%m-%d %H:%M:%S')" \
              --body "Automated downstream sync from subrepos to monorepo.

              **Changes pulled from:**
              - Multiple subrepos (see commit details)

              **Review:** Please verify all changes before merging." \
              --label "downstream-sync,automated" || echo "PR creation failed"
          else
            echo "No changes detected, cleaning up sync branch"
            git checkout main
            git branch -D "$sync_branch" || true
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}