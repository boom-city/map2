name: Push to Subrepos

on:
  push:
    branches:
      - main
      - master
    paths-ignore:
      - '.github/workflows/**'
      - '.github/scripts/**'
      - 'README.md'
      - 'CLAUDE.md'
      - 'dev-docs/**'

  workflow_dispatch:
    inputs:
      commit_range:
        description: 'Commit range to process (e.g., HEAD~5..HEAD)'
        required: false
        default: ''

env:
  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  GH_TOKEN: ${{ secrets.GH_PAT || secrets.GITHUB_TOKEN }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    name: Detect changed subrepos
    outputs:
      changed_subrepos: ${{ steps.detect.outputs.changed_subrepos }}
      has_changes: ${{ steps.detect.outputs.has_changes }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ env.GH_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Detect changed files
        id: detect
        run: |
          # Determine commit range
          if [ -n "${{ github.event.inputs.commit_range }}" ]; then
            COMMIT_RANGE="${{ github.event.inputs.commit_range }}"
          elif [ "${{ github.event_name }}" = "push" ]; then
            # For push events, compare with previous commit
            COMMIT_RANGE="${{ github.event.before }}..${{ github.sha }}"

            # Handle initial commit case
            if [ "${{ github.event.before }}" = "0000000000000000000000000000000000000000" ]; then
              COMMIT_RANGE="${{ github.sha }}"
            fi
          else
            # Default to last commit
            COMMIT_RANGE="HEAD~1..HEAD"
          fi

          echo "Analyzing commit range: $COMMIT_RANGE"

          # Get list of changed files
          if [[ "$COMMIT_RANGE" == *".."* ]]; then
            CHANGED_FILES=$(git diff --name-only $COMMIT_RANGE || git diff --name-only HEAD~1..HEAD)
          else
            CHANGED_FILES=$(git diff-tree --no-commit-id --name-only -r $COMMIT_RANGE || git diff --name-only HEAD~1..HEAD)
          fi

          echo "Changed files:"
          echo "$CHANGED_FILES"

          # Map changed files to subrepos
          CHANGED_SUBREPOS="[]"
          CONFIG_FILE=".github/subrepo-config.json"

          # Create temporary file for collecting unique subrepos
          TEMP_SUBREPOS=$(mktemp)

          # Process each changed file
          while IFS= read -r file; do
            if [ -z "$file" ]; then
              continue
            fi

            # Check each subrepo to see if this file belongs to it
            jq -c '.subrepos[]' "$CONFIG_FILE" | while IFS= read -r subrepo; do
              prefix=$(echo "$subrepo" | jq -r '.prefix')

              # Check if file is within this subrepo's prefix
              if [[ "$file" == "$prefix/"* ]] || [[ "$file" == "$prefix" ]]; then
                echo "$subrepo" >> "$TEMP_SUBREPOS"
                echo "File $file belongs to subrepo: $prefix"
                break
              fi
            done
          done <<< "$CHANGED_FILES"

          # Remove duplicates and create JSON array
          if [ -s "$TEMP_SUBREPOS" ]; then
            CHANGED_SUBREPOS=$(sort -u "$TEMP_SUBREPOS" | jq -R . | jq -s .)
            HAS_CHANGES="true"
          else
            CHANGED_SUBREPOS="[]"
            HAS_CHANGES="false"
          fi

          # Clean up
          rm -f "$TEMP_SUBREPOS"

          echo "Changed subrepos: $CHANGED_SUBREPOS"
          echo "changed_subrepos=$CHANGED_SUBREPOS" >> $GITHUB_OUTPUT
          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT

  push-changes:
    needs: detect-changes
    if: needs.detect-changes.outputs.has_changes == 'true'
    runs-on: ubuntu-latest
    name: Push changes to subrepos
    strategy:
      matrix:
        subrepo: ${{ fromJson(needs.detect-changes.outputs.changed_subrepos) }}
      max-parallel: 10
      fail-fast: false

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ env.GH_TOKEN }}

      - name: Setup Git
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "actions@github.com"

      - name: Parse subrepo info
        id: parse
        run: |
          SUBREPO='${{ matrix.subrepo }}'
          PREFIX=$(echo "$SUBREPO" | jq -r '.prefix')
          REMOTE=$(echo "$SUBREPO" | jq -r '.remote')
          BRANCH=$(echo "$SUBREPO" | jq -r '.branch')

          # Extract repository name from remote URL
          REPO_NAME=$(echo "$REMOTE" | sed -E 's|.*/([^/]+)\.git$|\1|')
          REPO_OWNER=$(echo "$REMOTE" | sed -E 's|.*github\.com[:/]([^/]+)/.*|\1|')

          echo "prefix=$PREFIX" >> $GITHUB_OUTPUT
          echo "remote=$REMOTE" >> $GITHUB_OUTPUT
          echo "branch=$BRANCH" >> $GITHUB_OUTPUT
          echo "repo_name=$REPO_NAME" >> $GITHUB_OUTPUT
          echo "repo_owner=$REPO_OWNER" >> $GITHUB_OUTPUT

      - name: Check if remote repository exists
        id: check_repo
        run: |
          REPO_OWNER="${{ steps.parse.outputs.repo_owner }}"
          REPO_NAME="${{ steps.parse.outputs.repo_name }}"

          if gh repo view "$REPO_OWNER/$REPO_NAME" &>/dev/null; then
            echo "Repository exists"
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "Repository does not exist"
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}

      - name: Create remote repository if needed
        if: steps.check_repo.outputs.exists == 'false'
        run: |
          REPO_OWNER="${{ steps.parse.outputs.repo_owner }}"
          REPO_NAME="${{ steps.parse.outputs.repo_name }}"

          echo "Creating repository: $REPO_OWNER/$REPO_NAME"

          # Create repository (adjust visibility as needed)
          gh repo create "$REPO_OWNER/$REPO_NAME" \
            --private \
            --description "Subrepo for ${{ steps.parse.outputs.prefix }}" \
            || echo "Failed to create repository"
        env:
          GH_TOKEN: ${{ env.GH_TOKEN }}

      - name: Clone and update subrepo
        run: |
          PREFIX="${{ steps.parse.outputs.prefix }}"
          REMOTE="${{ steps.parse.outputs.remote }}"
          BRANCH="${{ steps.parse.outputs.branch }}"

          # Create temporary directory for subrepo
          TEMP_REPO=$(mktemp -d)

          # Try to clone existing repo, or initialize if it doesn't exist
          if ! git clone "$REMOTE" "$TEMP_REPO" 2>/dev/null; then
            echo "Initializing new repository"
            git init "$TEMP_REPO"
            cd "$TEMP_REPO"
            git checkout -b "$BRANCH"
            git remote add origin "$REMOTE"
          else
            cd "$TEMP_REPO"
            git checkout "$BRANCH" || git checkout -b "$BRANCH"
          fi

          # Copy files from monorepo to subrepo
          cd "${{ github.workspace }}"

          # Ensure source directory exists
          if [ -d "$PREFIX" ]; then
            # Clear existing files in temp repo (except .git)
            find "$TEMP_REPO" -mindepth 1 -maxdepth 1 -name ".git" -prune -o -exec rm -rf {} + 2>/dev/null || true

            # Copy all files from prefix directory
            cp -r "$PREFIX"/* "$TEMP_REPO/" 2>/dev/null || true
            cp -r "$PREFIX"/.[^.]* "$TEMP_REPO/" 2>/dev/null || true
          fi

          # Commit and push changes
          cd "$TEMP_REPO"

          # Add all files
          git add -A

          # Check if there are changes to commit
          if [ -n "$(git status --porcelain)" ]; then
            # Get the last commit message from the monorepo
            cd "${{ github.workspace }}"
            COMMIT_MSG=$(git log -1 --pretty=%B)

            cd "$TEMP_REPO"
            FULL_COMMIT_MSG="$COMMIT_MSG"$'\n\n'"Synced from monorepo: ${{ github.repository }}@${{ github.sha }}"
            git commit -m "$FULL_COMMIT_MSG"

            # Push to remote
            git push origin "$BRANCH" --force || {
              echo "Failed to push changes"
              exit 1
            }

            echo "✓ Successfully pushed changes to $REMOTE"
          else
            echo "No changes to push for $PREFIX"
          fi

          # Cleanup
          rm -rf "$TEMP_REPO"

      - name: Update push status
        if: always()
        run: |
          PREFIX="${{ steps.parse.outputs.prefix }}"
          STATUS="${{ job.status }}"

          if [ "$STATUS" = "success" ]; then
            echo "✓ Successfully synced: $PREFIX"
          else
            echo "✗ Failed to sync: $PREFIX"
          fi

  summary:
    needs: [detect-changes, push-changes]
    if: always()
    runs-on: ubuntu-latest
    name: Generate sync summary

    steps:
      - name: Create summary
        run: |
          echo "# Subrepo Push Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Commit:** ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
          echo "**Author:** ${{ github.actor }}" >> $GITHUB_STEP_SUMMARY
          echo "**Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ needs.detect-changes.outputs.has_changes }}" = "true" ]; then
            echo "## Changed Subrepos" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The following subrepos were updated:" >> $GITHUB_STEP_SUMMARY
            echo '```json' >> $GITHUB_STEP_SUMMARY
            echo '${{ needs.detect-changes.outputs.changed_subrepos }}' | jq . >> $GITHUB_STEP_SUMMARY
            echo '```' >> $GITHUB_STEP_SUMMARY
          else
            echo "No subrepo changes detected." >> $GITHUB_STEP_SUMMARY
          fi